# Отчет по лабораторной работе 2
# Программирование на R

**Дата:** 2025-10-23

**Семестр:** 2 курс 1 полугодие - 3 семестр

**Группа:** ПИН-б-о-24-1(1)

**Дисциплина:** Технологии программирования

**Студент:** Герда Никита Андреевич

## Цель работы
Познакомиться с особенностями программирования в R. Решить задания в соответствующем стиле программирования. Составить отчет.

## Теоретическая часть
**Процедурный стиль** предоставляет возможность программисту определять каждый шаг в
процессе решения задачи. Переменная состоит из имени и выделенной области памяти, которая соответствует ей. 
Для объявления или, другими словами, создания переменной используются **директивы** (ключевые слова, конструкции). 

**Функция** – это подпрограмма специального вида, которая может принимать на вход параметры, выполнять различные действий и передавать результаты работы. 

**Процедура** – это независимая именованная часть программы, которую после однократного описания можно многократно вызвать по имени из последующих частей программы для выполнения определенных действий.

**Структурное программирование** – методология разработки программного
обеспечения, в основе которой лежит представление программы в виде иерархической
структуры блоков.

В соответствии с данной методологией любая программа строится без использования
оператора goto из трех базовых управляющих структур: последовательность, ветвление, цикл;
кроме того, используются подпрограммы. При этом разработка программы ведется пошагово,
методом «сверху вниз».

**Цель структурного программирования** – повысить производительность труда
программистов, в том числе при разработке больших и сложных программных комплексов,
сократить число ошибок, упростить отладку, модификацию и сопровождение программного
обеспечения.

**Теорема Бёма – Якопини** – положение структурного программирования, согласно
которому любой исполняемый алгоритм может быть преобразован к структурированному
виду, то есть такому виду, когда ход его выполнения определяется только при помощи трех
структур управления: последовательной, ветвлений и повторов или циклов.

**Цикл** – разновидность управляющей конструкции в высокоуровневых языках
программирования, предназначенная для организации многократного исполнения набора
инструкций.

**Бесконечный цикл** – цикл, написанный таким образом, что условие выхода из него
никогда не выполняется.

**Цикл с предусловием** – цикл, который выполняется, пока истинно некоторое условие,
указанное перед его началом. Это условие проверяется до выполнения тела цикла, поэтому
тело может быть не выполнено ни разу (если условие с самого начала ложно). В большинстве
процедурных языков программирования реализуется оператором while, отсюда его второе
название – while-цикл.

**Цикл со счетчиком** – цикл, в котором некоторая переменная изменяет свое значение
от заданного начального значения до конечного значения с некоторым шагом, и для каждого
значения этой переменной тело цикла выполняется один раз.
Досрочный выход из цикла. Команда досрочного выхода применяется, когда
необходимо прервать выполнение цикла, в котором условие выхода еще не достигнуто. Такое
бывает, например, когда при выполнении тела цикла обнаруживается ошибка, после которой
дальнейшая работа цикла не имеет смысла.

Пропуск итерации. Данный оператор применяется, когда в текущей итерации цикла
необходимо пропустить все команды до конца тела цикла. При этом сам цикл прерываться не
должен, условия продолжения или выхода должны вычисляться обычным образом.

Объектно-ориентированное программирование (ООП) – методология
программирования, основанная на представлении программы в виде совокупности объектов,
каждый из которых является экземпляром определенного класса, а классы образуют иерархию
наследования.
Принципы ООП по Алану Кею

 - все является объектом;
 - вычисления осуществляются путем взаимодействия (обмена данными) между
объектами, при котором один объект требует, чтобы другой объект выполнил некоторое
действие;
 - объекты взаимодействуют, посылая и получая сообщения;
 - сообщение – это запрос на выполнение действия, дополненный набором
   аргументов, которые могут понадобиться при выполнении действия;
 - каждый объект имеет независимую память, которая состоит из других
   объектов;
 - каждый объект является представителем (экземпляром) класса, который
   выражает общие свойства объектов.
 - в классе задается поведение (функциональность) объекта.
 - все объекты, которые являются экземплярами одного класса, могут
   выполнять одни и те же действия;
 - классы организованы в единую древовидную структуру с общим корнем,
   называемую иерархией наследования 
 - память и поведение, связанное с    экземплярами определенного класса,
   автоматически доступны любому    классу, расположенному ниже в
   иерархическом дереве.
 - программа    представляет собой набор объектов, имеющих состояние и
   поведение;
 - устойчивость и управляемость системы обеспечивается за счет четкого
   разделения ответственности объектов (за каждое действие отвечает
   определенный объект), однозначного определения интерфейсов
   межобъектного взаимодействия и полной изолированности внутренней
   структуры объекта от внешней среды (инкапсуляции).

Механизмы ООП
**Абстракция** – придание объекту характеристик, которые отличают его от всех
объектов, четко определяя его концептуальные границы;

**Инкапсуляция** – можно скрыть ненужные внутренние подробности работы объекта от
окружающего мира (алгоритмы работы хранятся вместе с данными);

**Наследование** – можно создавать специализированные классы на основе базовых
(позволяет избегать написания повторного кода);

**Полиморфизм** – в разных объектах одна и та же операция может выполнять различные
функции;

**Композиция** – объект может быть составным и включать другие объекты.

Некоторые понятия

Объект – абстракция данных;

**Объект** – это отдельный представитель класса, имеющий конкретное состояние и
поведение, полностью определяемое классом;
Объект: тип, методы,
**Данные** – объекты и отношения между ними;

**Класс** – это способ описания сущности, определяющий состояние и поведение,
зависящее от этого состояния, а также правила для взаимодействия с данной сущностью
(контракт)

С точки зрения программирования класс можно рассматривать как набор данных
(полей, атрибутов, членов класса) и функций для работы с ними (методов).

**Атрибут класса** – содержательная характеристика класса, описывающая множество
значений, которые могут принимать отдельные объекты этого класса

**Методы класса** – функция, которая может выполнять какие-либо действия над
данными (свойствами) класса.

**Дженерик (обобщенная функция)** – функция, способная принимать разные структуры
данных (разные классы), и работающая по-разному с данными структурами.

**R** – язык программирования для научных вычислений и анализа данных с упором на
визуализацию и воспроизводимость;

**R** – свободное кроссплатформенное программное обеспечение с открытым исходным
кодом;

**R** – интерпретируемый язык с интерфейсом командной строки;

**R** – мультипарадигмальный, векторный язык, сочетающий в себе:

 - функциональное программирование;
 - процедурное программирование;
 - объектно-ориентированное программирование;
 - рефлексивное программирование.

**Векторизация** – поэлементное одновременное выполнение действий над всеми
элементами.

Основные объекты языка:

**Вектор** – основной объект языка R. Вектор может содержать более одного значения,
все объекты в векторе имеют одну природу.

**Лист** – элемент языка R который может содержать разные по размеру и типу данных
векторы.

**Дата фрейм** – элемент языка R который может содержать одинаковые по размеру, но
разные по типу данных векторы. Дата фрейм является разновидностью листа

Некоторые объекты языка R:

**Матрица (matrix)** представляет собой двумерную совокупность числовых, логических
или текстовых величин.

**Массив (array)** – это совокупность некоторых однотипных элементов, обладающая
размерностью больше двух.

**Итерация** – организация обработки данных, при которой действия повторяются
многократно. В программировании итерации чаще рассматриваются в качестве элементов
структурного программирования, а именно как единичный шаг выполнения цикла. На
практике итерации также важны и в функциональном программировании, например в качестве
итерабельного процесса можно рассматривать применение одной и той же функции к разным
элементам.

**Вариации функции map. map_***
Функция map на выходе выдает список, аналогичной структуры, однако часто
необходимо сразу преобразовать вывод в некоторый вариант, для этого используются
производных от функции map:
map(.x, .f, ...)
map_if(.x, .p, .f, ...)
map_at(.x, .at, .f, ...)
map_lgl(.x, .f, ...)
map_chr(.x, .f, ...)
map_int(.x, .f, ...)
map_dbl(.x, .f, ...)
map_dfr(.x, .f, ..., .id = NULL)
map_dfc(.x, .f, ...)
walk(.x, .f, ...)

**Конвейер** – инструмент для передачи значения исходной функции в последующую.
Конвейер представляет типичный элемент функционального программирования. В языке R
конвейер имеет вид %>%.

Существует несколько методов для запуска кода параллельно. В языке
программирования R, для распараллеливания выполнения кода можно использовать пакета из
ядра языка parallel, так и другие пакеты, например foreach и future.apply.
Методы разделения задачи для решения в параллельном стиле:
1. Разделение на задачи. Каждую из задач можно выполнить независимо друг от друга.
В данных задачах используются разные данные.
2. Разделение по данным. Данный метод встречается часто для обработки больших
данных.

Существует два варианта реализации парадигмы параллельного программирования:
модель «Master-worker» (мастер-работник), также встречается в названии «Master-slave» и
модель Map-reduce (уменьшение карты).
На Map-шаге происходит предварительная обработка входных данных. Для этого один
из компьютеров (называемый главным узлом – master node) получает входные данные задачи,
разделяет их на части и передает другим компьютерам (рабочим узлам — worker node) для
предварительной обработки.
На Reduce-шаге происходит свертка предварительно обработанных данных. Главный
узел получает ответы от рабочих узлов и на их основе формирует результат – решение задачи,
которая изначально формулировалась.
Модель Master-worker наиболее типичная для простых параллельных вычислений.
## Практическая часть

### Выполненные задачи
- [x] Задача 1: Написать программу, выполненную в процедурном стиле. Программа должна быть выполнена в виде псевдокода, в виде блок-схемы и на языке высокого уровня (ЯВУ) (здесь и далее, если не оговорено иное, при отсылке к ЯВУ необходимо выполнять код на языке R). Для построения блоксхемы рекомендуется использовать ресурс draw.io или аналогичную программу. Построение блок схемы делается с учетом правил, содержащихся в презентации Императивное (процедурное) программирование.
**Вариант 3**
Напишите программу, подсчитывающую среднее количество занятий в неделю. Программа запрашивает информацию о количестве занятий в день (по дням недели). На выходе программа указывает среднее количество занятий в неделю с округлением до ближайшего целого числа.
- [x] Задача 2: Опишите, представленный код в виде псевдокода и ответьте на вопрос, что будет получено при передаче функции числа 7? Также реализуйте данный алгоритм на ЯВУ. 
```assembler
foo:
 cmp $0, %edi
 jg calc
 mov $1, %eax
 jmp exit
calc:
 push %edi
 sub $1, %edi
 call foo
 pop %edi
 imul %edi, %eax
exit:
 ret
```
Это функция с одним входным параметром, для которой ABI (двоичный интерфейс приложений)
предписывает передачу одного параметра через регистр %edi, а передачу возвращаемого значения через
регистр %eax. 
Замечания:
1) Команда 'imul src, dest' умножает src на dest и кладет результат в dest.
2) Не нужно думать о переполнении. Его здесь не будет.
- [x] Задача 3: Написать программу, выполненную в структурном стиле. Программа
должна рассчитывать площадь фигур (программа должна корректно отрабатывать данные
согласно варианту в приложении А). На вход программа запрашивает строку, если в нее
введено название фигуры, то программа запрашивает необходимые параметры фигуры, если
введено значение отличное от названия фигуры, то программа повторно предлагает ввести
название фигуры, если пользователь не справляется с этой задачей более 3 раз подряд, то
программа сообщает о некорректности действий пользователя и завершается. В случае
введения корректных данных программа должна выдать ответ, а также описание хода
решения.
Программа должна быть выполнена в виде блок-схемы и на ЯВУ.
- [x] Задача 4: Написать программу вычисляющую площадь неправильного
многоугольника. Многоугольник на плоскости задается целочисленными координатами своих
N вершин в декартовой системе. Стороны многоугольника не соприкасаются (за исключением
соседних - в вершинах) и не пересекаются. Программа в первой строке должна принимать
число N – количество вершин многоугольника, в последующих N строках – координаты
соответствующих вершин (вершины задаются в последовательности против часовой стрелки).
На выход программа должна выдавать площадь фигуры.
Программа должна быть выполнена в виде блок-схемы и на ЯВУ.
- [x] Задача 5: Создайте дженерик, принимающий вектор, содержащий параметры фигуры
и вычисляющий ее площадь. Для разных фигур создайте разные классы. В качестве метода по
умолчанию дженерик должен выводить сообщение о невозможности обработки данных.
- [x] Задача 6: Создайте генератор класса Микроволновая печь. В качестве данных класс
должен содержать сведения о мощности печи (Вт) и о состоянии дверцы (открыта или
закрыта). Данный класс должен обладать методами открыть и закрыть дверь микроволновки,
а также методом, отвечающим за приготовление пищи. Метод, отвечающий за приготовление
пищи, должен вводить систему в бездействие (используется Sys.sleep) на определенное
количество времени (которое зависит от мощности печи) и после выводить сообщение о
готовности пищи.
Выполните создание двух объектов этого класса со значением по умолчанию и с
передаваемыми значениями. Продемонстрируйте работу этих объектов по приготовлению
пищи.
- [x] Задача 7: Создайте класс копилка. Описание структуры классы выполните из своего
понимания копилки.
- [x] Задача 8: Предобработка данных. Создайте новый вектор my_vector, следующей строчкой:
```r
my_vector <- c(21, 18, 21, 19, 25, 20, 17, 17, 18, 22, 17, 18, 18, 19, 19, 27, 21, 20, 24, 17, 15, 24, 24, 29, 19, 14, 21, 17, 19, 18, 18, 20, 21, 21, 19, 17, 21, 13, 17, 13, 23, 15, 23, 24, 16, 17, 25, 24, 22)
```
В векторе my_vector отберите только те наблюдения, которые отклоняются от среднего
меньше, чем на одно стандартное отклонение. Сохраните эти наблюдения в новую
переменную my_vector2. При этом исходный вектор оставьте без изменений.
Полезные функции: mean(x) – среднее значение вектора x; sd(x) – стандартное
отклонение вектора x; abs(x) – абсолютное значение числа n
- [x] Задача 9: Напишите функцию get_negative_values, которая получает на вход dataframe
произвольного размера. Функция должна для каждой переменной в данных проверять, есть ли
в ней отрицательные значения. Если в переменной отрицательных значений нет, то эта
переменная нас не интересует, для всех переменных, в которых есть отрицательные значения
мы сохраним их в виде списка или матрицы, если число элементов будет одинаковым в каждой
переменной.
- [x] Задача 10: Используя тестовые данные пакета repurrrsive выполните следующее
задание. Создайте именованный список аналогичный по структуре списку sw_films, для
установления имени полезно использовать функцию set_names пакета purrr. В качестве имени
элементов списка необходимо использовать соответствующие название фильмов (обратите
внимание, что обращаться к элементам списка можно используя как индекс, так и название
элемента). Выполните задание в функциональном стиле.
- [x] Задача 11: Используя документацию пакета purrr опишите отличия и особенности функций семейства map_*. Приведите примеры реализации с использование различных тестовых данных. Данные можно брать из пакета datasets или создав свои тестовые наборы. Для просмотра данных из пакета datasets выполните код library(help = "datasets")
- [x] Задача 12: Используя технологию R Markdown создайте динамический документ с произвольными расчетами. Документ должен содержать вставки кода по типу inline и в виде чанков. В документе должно быть использовано различное форматирование. Также для оформления используйте каскадную таблицу стилей. Итоговый документ конвертируйте в html формат и представьте в отчете, соответствующие скрины.
- [x] Задание 13: Используя заранее подготовленные функции визуализируйте сведения о наиболее часто встречающихся словах из книг Джейн Остин по буквам английского алфавита. Книги, необходимые для анализа, находятся в пакете janeaustenr. Также для работы потребуется пакет stringr. После установки пакетов добавьте следующие функции:
```r
extract_words <- function(book_name) {
 text <- subset(austen_books(), book == book_name)$text
 str_extract_all(text, boundary("word")) %>% unlist %>% tolower
}
janeausten_words <- function() {
 books <- austen_books()$book %>% unique %>% as.character
 words <- sapply(books, extract_words) %>% unlist
 words
}
max_frequency <- function(letter, words, min_length = 1) {
 w <- select_words(letter, words = words, min_length = min_length)
 frequency <- table(w)
 frequency[which.max(frequency)]
}
select_words <- function(letter, words, min_length = 1) {
 min_length_words <- words[nchar(words) >= min_length]
 grep(paste0("^", letter), min_length_words, value = TRUE)
}
```
Для решения задачи необходимо с помощью функции janeausten_words() создать новый
объект – вектор слов. Далее, используя одну из функций семейства apply, и заранее созданную
функцию max_frequency создать именованный вектор, содержащий значение максимально
встречающих слов английского алфавита, длиной не менее 5 букв.
Полезной для работы будет использование встроенной переменной letters, содержащей
строчные буквы английского алфавита. Для визуализации используйте функцию barplot() c
аргументом las = 2.
- [x] Задание 14: Распараллельте фрагмент кода, представленный ниже, используя вычислительный
кластер:
```r
for(iter in seq_len(50))
 result[iter] <- mean_of_rnorm(10000)
```
Для решения подгрузите функцию
```r
mean_of_rnorm <- function(n) {
 random_numbers <- rnorm(n)
 mean(random_numbers)
}
```

### Ключевые фрагменты кода
Задача 1:
```text
Начало
  sum = 0
  ДЛЯ i от 1 ДО 7 С ШАГОМ 1 
      ввод lessons
      sum = sum + lessons
  avg = sum / 7
  округлить avg
  вывод avg
Конец
```
```R
sum <- 0
for (i in 1:7) {
  lessons <- as.numeric(readline(paste("Введите количество занятий в день", i, ": ")))
  sum <- sum + lessons
}
avg <- sum / 7
rounded_avg <- round(avg)
cat("Среднее количество занятий в неделю:", rounded_avg, "\n")
```
Задача 3:
```R
# Программа для расчета площади фигур (ромб, трапеция, эллипс)
# Выполнена в структурном стиле

calculate_area <- function() {
  cat("=== КАЛЬКУЛЯТОР ПЛОЩАДИ ФИГУР ===\n")
  cat("Доступные фигуры: Ромб, Трапеция, Эллипс\n\n")
  
  attempts <- 0
  max_attempts <- 3
  
  while (attempts < max_attempts) {
    # Запрос названия фигуры
    shape <- readline(prompt = "Введите название фигуры: ")
    
    # Приведение к нижнему регистру для удобства сравнения
    shape_lower <- tolower(shape)
    
    # Проверка корректности введенной фигуры
    if (shape_lower %in% c("ромб", "трапеция", "эллипс")) {
      cat(paste("\nВыбрана фигура:", shape, "\n"))
      calculate_specific_area(shape_lower)
      return(TRUE)
    } else {
      attempts <- attempts + 1
      remaining_attempts <- max_attempts - attempts
      
      if (remaining_attempts > 0) {
        cat(paste("Ошибка: Фигура '", shape, "' не найдена.\n", sep = ""))
        cat(paste("Осталось попыток:", remaining_attempts, "\n\n"))
      }
    }
  }
  
  # Превышено количество попыток
  cat("\nПРЕВЫШЕНО максимальное количество некорректных попыток (3)\n")
  cat("Программа завершена из-за некорректных действий пользователя.\n")
  return(FALSE)
}

# Функция для расчета площади конкретной фигуры
calculate_specific_area <- function(shape) {
  if (shape == "ромб") {
    calculate_rhombus_area()
  } else if (shape == "трапеция") {
    calculate_trapezoid_area()
  } else if (shape == "эллипс") {
    calculate_ellipse_area()
  }
}

# Функция для расчета площади ромба
calculate_rhombus_area <- function() {
  cat("\n--- Расчет площади РОМБА ---\n")
  cat("Формула: S = (d1 * d2) / 2\n")
  cat("где d1, d2 - длины диагоналей\n\n")
  
  # Ввод длин диагоналей
  d1 <- as.numeric(readline(prompt = "Введите длину первой диагонали (d1): "))
  d2 <- as.numeric(readline(prompt = "Введите длину второй диагонали (d2): "))
  
  # Проверка корректности введенных данных
  if (is.na(d1) || is.na(d2) || d1 <= 0 || d2 <= 0) {
    cat("ОШИБКА: Диагонали должны быть положительными числами!\n")
    return()
  }
  
  # Расчет площади
  area <- (d1 * d2) / 2
  
  # Вывод решения
  cat("\n--- Ход решения ---\n")
  cat("Длина первой диагонали (d1) =", d1, "\n")
  cat("Длина второй диагонали (d2) =", d2, "\n")
  cat("Площадь ромба S = (d1 * d2) / 2 = (", d1, "*", d2, ") / 2 =", area, "\n")
  cat("\nРЕЗУЛЬТАТ: Площадь ромба =", area, "\n")
}

# Функция для расчета площади трапеции
calculate_trapezoid_area <- function() {
  cat("\n--- Расчет площади ТРАПЕЦИИ ---\n")
  cat("Формула: S = ((a + b) * h) / 2\n")
  cat("где a, b - длины оснований, h - высота\n\n")
  
  # Ввод параметров
  a <- as.numeric(readline(prompt = "Введите длину первого основания (a): "))
  b <- as.numeric(readline(prompt = "Введите длину второго основания (b): "))
  h <- as.numeric(readline(prompt = "Введите высоту трапеции (h): "))
  
  # Проверка корректности введенных данных
  if (is.na(a) || is.na(b) || is.na(h) || a <= 0 || b <= 0 || h <= 0) {
    cat("ОШИБКА: Все параметры должны быть положительными числами!\n")
    return()
  }
  
  # Расчет площади
  area <- ((a + b) * h) / 2
  
  # Вывод решения
  cat("\n--- Ход решения ---\n")
  cat("Длина первого основания (a) =", a, "\n")
  cat("Длина второго основания (b) =", b, "\n")
  cat("Высота трапеции (h) =", h, "\n")
  cat("Площадь трапеции S = ((a + b) * h) / 2 = ((", a, "+", b, ") *", h, ") / 2 =", area, "\n")
  cat("\nРЕЗУЛЬТАТ: Площадь трапеции =", area, "\n")
}

# Функция для расчета площади эллипса
calculate_ellipse_area <- function() {
  cat("\n--- Расчет площади ЭЛЛИПСА ---\n")
  cat("Формула: S = π * a * b\n")
  cat("где a - большая полуось, b - малая полуось\n")
  cat("π (пи) ≈ 3.14159\n\n")
  
  # Ввод полуосей
  a <- as.numeric(readline(prompt = "Введите длину большой полуоси (a): "))
  b <- as.numeric(readline(prompt = "Введите длину малой полуоси (b): "))
  
  # Проверка корректности введенных данных
  if (is.na(a) || is.na(b) || a <= 0 || b <= 0) {
    cat("ОШИБКА: Полуоси должны быть положительными числами!\n")
    return()
  }
  
  # Расчет площади
  area <- pi * a * b
  
  # Вывод решения
  cat("\n--- Ход решения ---\n")
  cat("Длина большой полуоси (a) =", a, "\n")
  cat("Длина малой полуоси (b) =", b, "\n")
  cat("π (пи) ≈", pi, "\n")
  cat("Площадь эллипса S = π * a * b =", pi, "*", a, "*", b, "=", area, "\n")
  cat("\nРЕЗУЛЬТАТ: Площадь эллипса =", area, "\n")
}

# Главная функция программы
main <- function() {
  success <- calculate_area()
  
  if (success) {
    cat("\n")
    cat(strrep("=", 50))
    cat("\nПрограмма успешно завершена!\n")
    cat("Спасибо за использование калькулятора!\n")
  }
}

# Запуск программы
main()
```
Задача 4:
```R
calculate_polygon_area <- function() {
  # Считываем количество вершин
  n <- as.integer(readline(prompt = "Введите количество вершин многоугольника (N): "))
  
  # Проверка корректности введенного количества вершин
  if (is.na(n) || n < 3) {
    cat("ОШИБКА: Многоугольник должен иметь как минимум 3 вершины.\n")
    return()
  }
  
  # Инициализация векторов для координат
  x_coords <- numeric(n)
  y_coords <- numeric(n)
  
  # Считываем координаты вершин
  cat("Введите координаты вершин в порядке против часовой стрелки:\n")
  for (i in 1:n) {
    coords <- readline(prompt = paste("Вершина", i, "(x y): "))
    coords_split <- strsplit(coords, " ")[[1]]
    
    # Проверка корректности введенных координат
    if (length(coords_split) != 2) {
      cat("ОШИБКА: Неверный формат координат. Используйте: x y\n")
      return()
    }
    
    x_coords[i] <- as.numeric(coords_split[1])
    y_coords[i] <- as.numeric(coords_split[2])
    
    # Проверка на числовые значения
    if (is.na(x_coords[i]) || is.na(y_coords[i])) {
      cat("ОШИБКА: Координаты должны быть числами.\n")
      return()
    }
  }
```
Задача 5:
```R
area <- function(x, ...) {
  UseMethod("area")
}

# Метод по умолчанию
area.default <- function(x, ...) {
  warning("Невозможно обработать данные: неподдерживаемый тип фигуры")
  NA
}

# Метод для круга (один параметр - радиус)
area.circle <- function(x, ...) {
  if(length(x) != 1 || !is.numeric(x) || x <= 0) {
    warning("Для круга требуется один положительный числовой параметр (радиус)")
    return(NA)
  }
  pi * x^2
}
```
Задача 6:
```R
# Конструктор класса Микроволновая печь
microwave_oven <- function(power = 800, door_open = FALSE) {
  # Проверка корректности мощности
  if (!is.numeric(power) || power <= 0) {
    stop("Мощность должна быть положительным числом")
  }
  
  # Проверка корректности состояния дверцы
  if (!is.logical(door_open)) {
    stop("Состояние дверцы должно быть логическим значением (TRUE/FALSE)")
  }
  
  structure(
    list(
      power = power,
      door_open = door_open
    ),
    class = "microwave_oven"
  )
}

# Метод для открытия дверцы
open_door <- function(x) {
  UseMethod("open_door")
}

open_door.microwave_oven <- function(x) {
  if (!x$door_open) {
    x$door_open <- TRUE
    message("Дверца микроволновки открыта")
  } else {
    message("Дверца уже открыта")
  }
  return(x)
}

# Метод для закрытия дверцы
close_door <- function(x) {
  UseMethod("close_door")
}
```
Задача 7:
```R
piggy_bank <- function(capacity = 1000, current_amount = 0, material = "керамика", broken = FALSE) {
  # Проверка корректности параметров
  if (!is.numeric(capacity) || capacity <= 0) {
    stop("Вместимость должна быть положительным числом")
  }
  
  if (!is.numeric(current_amount) || current_amount < 0) {
    stop("Текущая сумма должна быть неотрицательным числом")
  }
  
  if (current_amount > capacity) {
    stop("Текущая сумма не может превышать вместимость копилки")
  }
  
  if (!is.logical(broken)) {
    stop("Статус 'broken' должен быть логическим значением")
  }
  
  structure(
    list(
      capacity = capacity,
      current_amount = current_amount,
      material = material,
      broken = broken,
      creation_date = Sys.Date()
    ),
    class = "piggy_bank"
  )
}
```
Задача 8:
```R
# Создаем исходный вектор
my_vector <- c(21, 18, 21, 19, 25, 20, 17, 17, 18, 22, 17, 18, 18, 19, 19, 27, 21, 20,
               24, 17, 15, 24, 24, 29, 19, 14, 21, 17, 19, 18, 18, 20, 21, 21, 19, 17, 
               21, 13, 17, 13, 23, 15, 23, 24, 16, 17, 25, 24, 22)

# Вычисляем среднее значение и стандартное отклонение
mean_value <- mean(my_vector)
sd_value <- sd(my_vector)

# Выводим вычисленные значения для проверки
cat("Среднее значение:", mean_value, "\n")
cat("Стандартное отклонение:", sd_value, "\n")

# Отбираем наблюдения, которые отклоняются от среднего меньше чем на одно стандартное отклонение
my_vector2 <- my_vector[abs(my_vector - mean_value) < sd_value]

# Проверяем результат
cat("\nИсходный вектор my_vector:\n")
print(my_vector)
cat("Длина исходного вектора:", length(my_vector), "\n")

cat("\nНовый вектор my_vector2:\n")
print(my_vector2)
cat("Длина нового вектора:", length(my_vector2), "\n")

# Дополнительная проверка - покажем какие элементы были отобраны
cat("\nПроверка отбора:\n")
cat("Границы отбора: от", mean_value - sd_value, "до", mean_value + sd_value, "\n")
cat("Количество элементов в исходном векторе:", length(my_vector), "\n")
cat("Количество элементов в новом векторе:", length(my_vector2), "\n")
cat("Отобрано", length(my_vector2), "из", length(my_vector), "элементов\n")

# Визуализируем результат для наглядности
cat("\nВизуализация отбора:\n")
for (i in 1:length(my_vector)) {
  deviation <- abs(my_vector[i] - mean_value)
  if (deviation < sd_value) {
    cat(sprintf("Элемент %2d: %2d (отклонение: %.2f) - ВКЛЮЧЕН\n", i, my_vector[i], deviation))
  } else {
    cat(sprintf("Элемент %2d: %2d (отклонение: %.2f) - исключен\n", i, my_vector[i], deviation))
  }
}
```
Задача 9:
```R
get_negative_values <- function(df) {
  # Создаем пустой список для хранения результатов
  result_list <- list()
  
  # Перебираем все столбцы dataframe
  for (col_name in names(df)) {
    # Получаем столбец
    column <- df[[col_name]]
    
    # Отбираем только отрицательные значения (исключая NA)
    negative_values <- column[!is.na(column) & column < 0]
    
    # Если в столбце есть отрицательные значения, добавляем их в результат
    if (length(negative_values) > 0) {
      result_list[[col_name]] <- negative_values
    }
  }
  
  # Проверяем, можно ли преобразовать в матрицу
  # Для этого все векторы в списке должны быть одинаковой длины
  if (length(result_list) > 0) {
    lengths <- sapply(result_list, length)
    
    # Если все векторы одинаковой длины, преобразуем в матрицу
    if (length(unique(lengths)) == 1 && all(lengths > 0)) {
      # Создаем матрицу, где каждый столбец - это вектор отрицательных значений
      result_matrix <- matrix(unlist(result_list), 
                              nrow = lengths[1], 
                              ncol = length(result_list),
                              byrow = FALSE)
      
      # Устанавливаем имена столбцов
      colnames(result_matrix) <- names(result_list)
      
      return(result_matrix)
    }
  }
  
  # Если матрицу создать нельзя или список пуст, возвращаем список
  return(result_list)
}
```
Задача 10:
```R
if (!require(repurrrsive)) install.packages("repurrrsive")
if (!require(purrr)) install.packages("purrr")
if (!require(tidyverse)) install.packages("tidyverse")

library(repurrrsive)
library(purrr)
library(tidyverse)

# Смотрим на структуру исходного списка sw_films
str(sw_films[1:2], max.level = 1)

# Создаем именованный список с названиями фильмов в качестве имен
named_sw_films <- sw_films %>% 
  set_names(map_chr(sw_films, "title"))

# Проверяем результат
str(named_sw_films[1:2], max.level = 1)
names(named_sw_films)
```
Задача 11:
```R
# Загружаем необходимые пакеты
library(purrr)
library(datasets)

# Просматриваем доступные datasets
# library(help = "datasets")

cat("=== Функции семейства map_* в purrr ===\n\n")

# Создаем тестовые данные
test_list <- list(a = 1:5, b = 6:10, c = 11:15)
test_df <- data.frame(x = 1:5, y = 6:10, z = letters[1:5])
test_numeric <- c(1.5, 2.7, 3.2, 4.8, 5.1)
test_character <- c("apple", "banana", "cherry")
test_logical <- c(TRUE, FALSE, TRUE, TRUE, FALSE)

cat("1. map() - возвращает список:\n")
cat("   Применяет функцию к каждому элементу, возвращает список того же размера\n\n")

result_map <- map(test_list, ~ .x * 2)
print(result_map)

cat("\n2. map_lgl() - возвращает логический вектор:\n")
cat("   Функция должна возвращать логические значения\n\n")

result_lgl <- map_lgl(test_list, ~ mean(.x) > 5)
print(result_lgl)
```
Задача 12:
```R
films_df <- map_dfr(sw_films, ~{
  data.frame(
    Название = .x$title,
    Режиссер = .x$director,
    Продюсер = .x$producer,
    `Дата выхода` = .x$release_date,
    `Количество персонажей` = length(.x$characters),
    `Количество планет` = length(.x$planets),
    stringsAsFactors = FALSE
  )
})
```
Задача 13:
```R
# Загрузка необходимых пакетов
library(janeaustenr)
library(stringr)
library(purrr)

# Функции из задания
extract_words <- function(book_name) {
  text <- subset(austen_books(), book == book_name)$text
  str_extract_all(text, boundary("word")) %>% unlist %>% tolower
}

janeausten_words <- function() {
  books <- austen_books()$book %>% unique %>% as.character
  words <- sapply(books, extract_words) %>% unlist
  words
}

max_frequency <- function(letter, words, min_length = 1) {
  w <- select_words(letter, words = words, min_length = min_length)
  frequency <- table(w)
  frequency[which.max(frequency)]
}

select_words <- function(letter, words, min_length = 1) {
  min_length_words <- words[nchar(words) >= min_length]
  grep(paste0("^", letter), min_length_words, value = TRUE)
}
```
Задача 14:
```R
mean_of_rnorm <- function(n) {
  random_numbers <- rnorm(n)
  mean(random_numbers)
}

# Способ 1: Использование пакета parallel (базовый)
library(parallel)

# Создаем вычислительный кластер
cl <- makeCluster(detectCores() - 1) # Оставляем одно ядро свободным

# Экспортируем функцию в кластер
clusterExport(cl, "mean_of_rnorm")

# Распараллеленная версия
result_parallel <- parSapply(cl, seq_len(50), function(iter) {
  mean_of_rnorm(10000)
})

# Останавливаем кластер
stopCluster(cl)

# Выводим результаты
cat("Параллельные вычисления завершены\n")
cat("Среднее значение результатов:", mean(result_parallel), "\n")
cat("Стандартное отклонение результатов:", sd(result_parallel), "\n")
```

## Результаты выполнения

### Пример работы программы
Задача 1:
```bash
Введите количество занятий в день 1: 3
Введите количество занятий в день 2: 4
Введите количество занятий в день 3: 2
Введите количество занятий в день 4: 5
Введите количество занятий в день 5: 3
Введите количество занятий в день 6: 0
Введите количество занятий в день 7: 1
Среднее количество занятий в неделю: 3
```
Задача 3:
```bash
> main() === КАЛЬКУЛЯТОР ПЛОЩАДИ ФИГУР ===
Доступные фигуры: Ромб, Трапеция, Эллипс Введите название фигуры: Ромб  Выбрана фигура: Ромб 

--- Расчет площади РОМБА ---
Формула: S = (d1 * d2) / 2
где d1, d2 - длины диагоналей Введите длину первой диагонали (d1): 15 Введите длину второй диагонали (d2): 15  --- Ход решения ---
Длина первой диагонали (d1) = 15 
Длина второй диагонали (d2) = 15 
Площадь ромба S = (d1 * d2) / 2 = ( 15 * 15 ) / 2 = 112.5 

РЕЗУЛЬТАТ: Площадь ромба = 112.5 

==================================================
Программа успешно завершена!
Спасибо за использование калькулятора!
```
Задача 4:
```bash
Введите количество вершин многоугольника (N): 3
Введите координаты вершин в порядке против часовой стрелки:
Вершина 1 (x y): 0 0
Вершина 2 (x y): 2 0
Вершина 3 (x y): 1 2

Координаты вершин многоугольника:
Вершина 1 : ( 0 , 0 )
Вершина 2 : ( 2 , 0 )
Вершина 3 : ( 1 , 2 )

--- Ход решения ---
Формула площади Гаусса: S = 0.5 * |Σ(x_i * y_{i+1} - x_{i+1} * y_i)|
Вычисленная сумма:  4 
Площадь многоугольника: S = 0.5 * | 4 | = 2 

РЕЗУЛЬТАТ: Площадь многоугольника = 2 
```
Задача 5:
```bash
> area(circle_param)    # 78.53982
[1] 78.53982
attr(,"class")
[1] "circle"
> area(rectangle_param) # 24
[1] 24
> area(triangle_param)  # 6
[1] 6
> area(invalid_param)   # Предупреждение и NA
[1] NA
Предупреждение:
В area.default(invalid_param) :
  Невозможно обработать данные: неподдерживаемый тип фигуры
```
Задача 6:
```bash
=== Демонстрация работы класса Микроволновая печь ===

1. Создание микроволновки со значениями по умолчанию:
Микроволновая печь
Мощность: 800 Вт
Состояние дверцы: закрыта 

2. Создание микроволновки с заданными параметрами:
Микроволновая печь
Мощность: 1200 Вт
Состояние дверцы: открыта 

3. Работа с первой микроволновкой:
Дверца уже закрыта
Приготовление суп началось...
Мощность: 800 Вт
Время: 3 секунд
суп готова(о)!

4. Работа со второй микроволновкой:
Дверца микроволновки закрыта
Автоматическое время приготовления: 40 секунд
Приготовление картофель началось...
Мощность: 1200 Вт
Время: 40 секунд
картофель готова(о)!

5. Попытка готовки с открытой дверцей:
Дверца микроволновки открыта
Ошибка: Невозможно начать приготовление: дверца открыта!

6. Приготовление с автоматическим расчетом времени для разной мощности:
Автоматическое время приготовления: 80 секунд
Приготовление каша началось...
Мощность: 600 Вт
Время: 80 секунд
каша готова(о)!
Автоматическое время приготовления: 48 секунд
Приготовление горячий бутерброд началось...
Мощность: 1000 Вт
Время: 48 секунд
горячий бутерброд готова(о)!
```
Задача 7:
```bash
=== Демонстрация работы класса Копилка ===

1. Создание копилки со значениями по умолчанию:
Копилка
Материал: керамика 
Вместимость: 1000 
Текущая сумма: 0 
Статус: целая 
Дата создания: 2025-10-30 
Заполненность: 0 %

2. Создание копилки с заданными параметрами:
Копилка
Материал: стекло 
Вместимость: 5000 
Текущая сумма: 1000 
Статус: целая 
Дата создания: 2025-10-30 
Заполненность: 20 %

3. Работа с первой копилкой:
Добавлено 100 денег. Текущая сумма: 100
Добавлено 50 денег. Текущая сумма: 150
Текущий баланс: 150 / 1000
Свободное место: 850
Слышен небольшой звон монет

4. Попытка добавить слишком много денег:
Нельзя добавить деньги: копилка переполнится!

5. Заполнение копилки до конца:
Добавлено 850 денег. Текущая сумма: 1000
Копилка полностью заполнена!
Текущий баланс: 1000 / 1000
Свободное место: 0
Копилка не гремит - она полностью заполнена!

6. Разбитие копилки:
Разбиваем копилку... Достаем 1000 денег!
Копилка сломана. Больше нельзя добавлять деньги.
Копилка
Материал: керамика 
Вместимость: 1000 
Текущая сумма: 0 
Статус: сломана 
Дата создания: 2025-10-30 
Заполненность: 0 %

7. Попытка добавить деньги в сломанную копилку:
Копилка сломана! Нельзя добавить деньги.

8. Создание и использование металлической копилки:
Добавлено 500 денег. Текущая сумма: 500
Добавлено 300 денег. Текущая сумма: 800
Текущий баланс: 800 / 2000
Свободное место: 1200
Слышен небольшой звон монет

9. Информация о всех копилках:
Копилка
Материал: керамика 
Вместимость: 1000 
Текущая сумма: 0 
Статус: сломана 
Дата создания: 2025-10-30 
Заполненность: 0 %
Копилка
Материал: стекло 
Вместимость: 5000 
Текущая сумма: 1000 
Статус: целая 
Дата создания: 2025-10-30 
Заполненность: 20 %
Копилка
Материал: металл 
Вместимость: 2000 
Текущая сумма: 800 
Статус: целая 
Дата создания: 2025-10-30 
Заполненность: 40 %
```
Задача 8:
```bash
реднее значение: 19.73469 
Стандартное отклонение: 3.510553 

Исходный вектор my_vector:
 [1] 21 18 21 19 25 20 17 17 18 22 17 18 18 19 19 27 21 20 24 17 15 24 24 29 19 14 21 17 19 18 18 20 21 21 19 17 21 13 17
[40] 13 23 15 23 24 16 17 25 24 22
Длина исходного вектора: 49 

Новый вектор my_vector2:
 [1] 21 18 21 19 20 17 17 18 22 17 18 18 19 19 21 20 17 19 21 17 19 18 18 20 21 21 19 17 21 17 23 23 17 22
Длина нового вектора: 34 

Проверка отбора:
Границы отбора: от 16.22414 до 23.24525 
Количество элементов в исходном векторе: 49 
Количество элементов в новом векторе: 34 
Отобрано 34 из 49 элементов

Визуализация отбора:
Элемент  1: 21 (отклонение: 1.27) - ВКЛЮЧЕН
Элемент  2: 18 (отклонение: 1.73) - ВКЛЮЧЕН
Элемент  3: 21 (отклонение: 1.27) - ВКЛЮЧЕН
Элемент  4: 19 (отклонение: 0.73) - ВКЛЮЧЕН
Элемент  5: 25 (отклонение: 5.27) - исключен
Элемент  6: 20 (отклонение: 0.27) - ВКЛЮЧЕН
Элемент  7: 17 (отклонение: 2.73) - ВКЛЮЧЕН
Элемент  8: 17 (отклонение: 2.73) - ВКЛЮЧЕН
Элемент  9: 18 (отклонение: 1.73) - ВКЛЮЧЕН
Элемент 10: 22 (отклонение: 2.27) - ВКЛЮЧЕН
Элемент 11: 17 (отклонение: 2.73) - ВКЛЮЧЕН
Элемент 12: 18 (отклонение: 1.73) - ВКЛЮЧЕН
Элемент 13: 18 (отклонение: 1.73) - ВКЛЮЧЕН
Элемент 14: 19 (отклонение: 0.73) - ВКЛЮЧЕН
Элемент 15: 19 (отклонение: 0.73) - ВКЛЮЧЕН
Элемент 16: 27 (отклонение: 7.27) - исключен
Элемент 17: 21 (отклонение: 1.27) - ВКЛЮЧЕН
Элемент 18: 20 (отклонение: 0.27) - ВКЛЮЧЕН
Элемент 19: 24 (отклонение: 4.27) - исключен
Элемент 20: 17 (отклонение: 2.73) - ВКЛЮЧЕН
Элемент 21: 15 (отклонение: 4.73) - исключен
Элемент 22: 24 (отклонение: 4.27) - исключен
Элемент 23: 24 (отклонение: 4.27) - исключен
Элемент 24: 29 (отклонение: 9.27) - исключен
Элемент 25: 19 (отклонение: 0.73) - ВКЛЮЧЕН
Элемент 26: 14 (отклонение: 5.73) - исключен
Элемент 27: 21 (отклонение: 1.27) - ВКЛЮЧЕН
Элемент 28: 17 (отклонение: 2.73) - ВКЛЮЧЕН
Элемент 29: 19 (отклонение: 0.73) - ВКЛЮЧЕН
Элемент 30: 18 (отклонение: 1.73) - ВКЛЮЧЕН
Элемент 31: 18 (отклонение: 1.73) - ВКЛЮЧЕН
Элемент 32: 20 (отклонение: 0.27) - ВКЛЮЧЕН
Элемент 33: 21 (отклонение: 1.27) - ВКЛЮЧЕН
Элемент 34: 21 (отклонение: 1.27) - ВКЛЮЧЕН
Элемент 35: 19 (отклонение: 0.73) - ВКЛЮЧЕН
Элемент 36: 17 (отклонение: 2.73) - ВКЛЮЧЕН
Элемент 37: 21 (отклонение: 1.27) - ВКЛЮЧЕН
Элемент 38: 13 (отклонение: 6.73) - исключен
Элемент 39: 17 (отклонение: 2.73) - ВКЛЮЧЕН
Элемент 40: 13 (отклонение: 6.73) - исключен
Элемент 41: 23 (отклонение: 3.27) - ВКЛЮЧЕН
Элемент 42: 15 (отклонение: 4.73) - исключен
Элемент 43: 23 (отклонение: 3.27) - ВКЛЮЧЕН
Элемент 44: 24 (отклонение: 4.27) - исключен
Элемент 45: 16 (отклонение: 3.73) - исключен
Элемент 46: 17 (отклонение: 2.73) - ВКЛЮЧЕН
Элемент 47: 25 (отклонение: 5.27) - исключен
Элемент 48: 24 (отклонение: 4.27) - исключен
Элемент 49: 22 (отклонение: 2.27) - ВКЛЮЧЕН
```
Задача 9:
```bash
=== Тест 1 ===
$V1
[1]  -9.7 -10.0 -10.5  -7.8  -8.9

$V2
[1] -10.2 -10.1  -9.3 -12.2

$V3
[1]  -9.3 -10.9  -9.8


=== Тест 2 ===
$V2
[1] -0.3

$V3
[1] -1.0 -5.0 -1.2


=== Тест 3 ===
       V1   V2
[1,] -0.5 -0.3
[2,] -0.7 -2.0
[3,] -8.0 -1.2

=== Тест 4 (нет отрицательных значений) ===
list()

=== Тест 5 (разное количество отрицательных значений в столбцах) ===
$V1
[1] -1 -3 -5

$V2
[1] -4 -5

```
Задача 10:
```bash
List of 2
 $ :List of 14
 $ :List of 14
List of 2
 $ A New Hope          :List of 14
 $ Attack of the Clones:List of 14
Доступ по индексу (первый элемент):
 [1] "title"         "episode_id"    "opening_crawl" "director"      "producer"      "release_date"  "characters"   
 [8] "planets"       "starships"     "vehicles"      "species"       "created"       "edited"        "url"          

Доступ по имени ('A New Hope'):
 [1] "title"         "episode_id"    "opening_crawl" "director"      "producer"      "release_date"  "characters"   
 [8] "planets"       "starships"     "vehicles"      "species"       "created"       "edited"        "url"          

Доступ с использованием $:
 [1] "title"         "episode_id"    "opening_crawl" "director"      "producer"      "release_date"  "characters"   
 [8] "planets"       "starships"     "vehicles"      "species"       "created"       "edited"        "url"          

Названия всех фильмов:
A New Hope 
Attack of the Clones 
The Phantom Menace 
Revenge of the Sith 
Return of the Jedi 
The Empire Strikes Back 
The Force Awakens 

Режиссеры фильмов:
A New Hope :  George Lucas 
Attack of the Clones :  George Lucas 
The Phantom Menace :  George Lucas 
Revenge of the Sith :  George Lucas 
Return of the Jedi :  Richard Marquand 
The Empire Strikes Back :  Irvin Kershner 
The Force Awakens :  J. J. Abrams 

Даты выхода:
A New Hope вышел 1977-05-25
Attack of the Clones вышел 2002-05-16
The Phantom Menace вышел 1999-05-19
Revenge of the Sith вышел 2005-05-19
Return of the Jedi вышел 1983-05-25
The Empire Strikes Back вышел 1980-05-17
The Force Awakens вышел 2015-12-11
```
Задача 11:
```bash
=== Функции семейства map_* в purrr ===

1. map() - возвращает список:
   Применяет функцию к каждому элементу, возвращает список того же размера

$a
[1]  2  4  6  8 10

$b
[1] 12 14 16 18 20

$c
[1] 22 24 26 28 30


2. map_lgl() - возвращает логический вектор:
   Функция должна возвращать логические значения

    a     b     c 
FALSE  TRUE  TRUE 

3. map_int() - возвращает целочисленный вектор:
   Функция должна возвращать целые числа

Sepal.Length  Sepal.Width Petal.Length  Petal.Width      Species 
          35           23           43           22            3 

4. map_dbl() - возвращает числовой вектор (double):
   Функция должна возвращать числа с плавающей точкой

Sepal.Length  Sepal.Width Petal.Length  Petal.Width 
    5.843333     3.057333     3.758000     1.199333 

5. map_chr() - возвращает символьный вектор:
   Функция должна возвращать строки

Sepal.Length  Sepal.Width Petal.Length  Petal.Width      Species 
   "numeric"    "numeric"    "numeric"    "numeric"     "factor" 

6. map_dfr() - возвращает data.frame, объединяя по строкам:
   Каждый элемент должен возвращать data.frame или именованный вектор

     Species Mean_Sepal.Length Mean_Petal.Length
1     setosa             5.006             1.462
2 versicolor             5.936             4.260
3  virginica             6.588             5.552

7. map_dfc() - возвращает data.frame, объединяя по столбцам:
   Каждый элемент должен возвращать вектор одинаковой длины

New names:
• `` -> `...1`
• `` -> `...2`
• `` -> `...3`
# A tibble: 5 × 3
     col1  col2  col3
    <dbl> <dbl> <dbl>
1 -0.0175 2.23   4.64
2  1.29   3.18   2.73
3  2.40   3.97   3.78
4  1.35   1.99   1.08
5  1.50   0.475  1.85

8. walk() - выполняет функцию для побочных эффектов:
   Не возвращает значение, используется для вывода или сохранения

Фрукт: apple 
Фрукт: banana 
Фрукт: cherry 

9. map2() - работает с двумя наборами входных данных:
   Итерируется одновременно по двум векторам/спискам

[[1]]
[1] 5

[[2]]
[1] 7

[[3]]
[1] 9


10. pmap() - работает с произвольным количеством аргументов:
    Принимает список списков для более сложных итераций

$mean
 [1]   0.1447416   0.4129230   1.4758282 -10.0577024  -2.0470853  -4.1994423  -8.5116997  -0.9809626   1.0308950
[10]   0.6363176

$sd
[1] -0.2424151  0.6359430  2.5165468

$n
[1] 5.718912 3.325968 3.973358 4.735059 5.532399


11. map_if() - применяет функцию только к элементам, удовлетворяющим условию:
    Полезно для условного применения функций

$a
[1] 2 4 6

$b
[1] "hello"

$c
[1]  8 10 12

$d
[1] "world"


12. map_at() - применяет функцию только к указанным элементам:
    Указываем конкретные имена или индексы

$a
[1] 10 20 30 40 50

$b
[1]  6  7  8  9 10

$c
[1] 110 120 130 140 150


13. safely(), possibly(), quietly() - обработка ошибок:
    Полезно при работе с ненадежными операциями

[[1]]
[[1]]$result
[1] 2

[[1]]$error
NULL


[[2]]
[[2]]$result
[1] 3

[[2]]$error
NULL


[[3]]
[[3]]$result
[1] NaN

[[3]]$error
NULL


[[4]]
[[4]]$result
[1] 4

[[4]]$error
NULL


[1]   2   3 NaN   4

14. keep() и discard() - фильтрация элементов:
    keep сохраняет элементы, удовлетворяющие условию, discard - удаляет

Четные: 2 4 6 8 10 
Нечетные: 1 3 5 7 9 

15. reduce() и accumulate() - последовательное применение:
    reduce возвращает конечный результат, accumulate - все промежуточные

Факториал 5 (reduce): 120 
Факториалы 1-5 (accumulate): 1 2 6 24 120 

=== Сводка отличий ===
• map_* функции различаются типом возвращаемого значения:
  - map: список
  - map_lgl: логический вектор
  - map_int: целочисленный вектор
  - map_dbl: числовой вектор
  - map_chr: символьный вектор
  - map_dfr: data.frame (по строкам)
  - map_dfc: data.frame (по столбцам)
• walk: для побочных эффектов, не возвращает значение
• map2/pmap: для работы с несколькими входными данными
• map_if/map_at: для условного применения
• safely/possibly: для обработки ошибок
• keep/discard: для фильтрации
• reduce/accumulate: для последовательного применения
Предупреждения:
1: В sqrt(.x) : созданы NaN
2: В sqrt(.x) : созданы NaN
```
Задача 14:
```bash
Параллельные вычисления завершены
Среднее значение результатов: 0.002262748 
Стандартное отклонение результатов: 0.009430864 

Присоединяю пакет: ‘foreach’

Следующие объекты скрыты от ‘package:purrr’:

    accumulate, when

Загрузка требуемого пакета: iterators

Параллельные вычисления с foreach завершены
Среднее значение результатов: 0.0004650339 
Стандартное отклонение результатов: 0.01124678 

=== Сравнение с последовательной версией ===
Время последовательного выполнения: 0.024 секунд
Время параллельного выполнения: 0.025 секунд
Ускорение: 0.94 раз
Результаты эквивалентны: Mean relative difference: 0.1741898 

=== Итоговый результат ===
Итоговый вектор результатов (первые 10 элементов):
 [1] -0.011425692  0.005627527 -0.001599478  0.018896351 -0.007855230 -0.001102968 -0.021454016 -0.004138407 -0.023012272
[10]  0.017078330
Сводная статистика:
      Min.    1st Qu.     Median       Mean    3rd Qu.       Max. 
-0.0230123 -0.0077112 -0.0009225 -0.0007018  0.0040968  0.0289006 
```

### Тестирование
- [x] Модульные тесты пройдены
- [x] Интеграционные тесты пройдены
- [x] Производительность соответствует требованиям

## Выводы
1. Эволюция парадигм программирования направлена на повышение структурированности, управляемости и повторного использования кода. Текст демонстрирует логическое развитие от процедурного стиля 
(последовательность шагов) к структурному программированию (строгая иерархия из трёх базовых структур) и далее к объектно-ориентированному программированию 
(инкапсуляция данных и поведения в объекты). Каждая следующая методология решает проблемы предыдущей, такие как сложность отладки, модификации и масштабирования больших программ.
2. Язык R является мультипарадигмальным инструментом, ориентированным на эффективную обработку данных. Он сочетает элементы процедурного, функционального (векторизация, функции map, конвейер %>%) и объектно-ориентированного 
программирования. Его основная сила заключается в работе с векторными структурами данных и предоставлении удобных средств для итераций и преобразования данных, что делает его особенно мощным в задачах статистического анализа 
и Data Science.
3. Для решения сложных вычислительных задач используются методы параллельного программирования, которые концептуально разделяются на два подхода. Текст описывает две основные модели: «Master-worker» для простого распределения 
независимых задач и «MapReduce» для более сложных процессов, где данные сначала обрабатываются (Map), а затем агрегируются (Reduce). Это показывает, как парадигмы программирования адаптируются для повышения производительности 
за счёт использования нескольких вычислительных ресурсов.

## Ответы на контрольные вопросы
1. Хронология процедурных языков - 
**1950-е:** Fortran (1957), ALGOL (1958) - первые процедурные языки 
**1960-е:** COBOL (1959), BASIC (1964), PL/I (1964) 
**1970-е:** Pascal (1970), C (1972), Ada (1979) 
**1980-е:** Modula-2 (1978), C++ (1985) - добавляет ООП к процедурной основе Эволюция шла от машинно-ориентированных языков к более абстрактным, с улучшенными возможностями структурирования кода.
2. Спагетти-код (особенность и причины) - 
Код с хаотичной структурой, где поток управления сложно проследить из-за обилия переходов (goto). Напоминает запутанную тарелку спагетти. 
**Причины:** 
- Чрезмерное использование операторов безусловного перехода (goto) - Отсутствие структурированных конструкций (ветвлений, циклов) 
- Непродуманная архитектура программы 
- Многократные переходы между различными частями кода. 
Программы на ранних версиях BASIC с частыми GOTO создавали именно такой "спагетти-код".
3. Процедурный стиль и архитектура фон Неймана (взаимосвязь) - 
Процедурное программирование напрямую отражает архитектуру фон Неймана:

- Память - переменные в программе соответствуют ячейкам памяти
- Процессор - операторы программы соответствуют командам процессора
- Последовательное выполнение - отражает последовательную природу фон-неймановских вычислений
- Изменяемое состояние - соответствует изменению содержимого памяти

4. Цикл с постусловием - Цикл, в котором условие выхода проверяется после выполнения тела цикла, гарантируя как минимум однократное выполнение операторов тела. В языке R реализуется конструкцией repeat с проверкой условия и оператором break для выхода.
5. Совместный цикл - Цикл, сочетающий в себе особенности нескольких типов циклических конструкций, например, объединяющий элементы цикла с предусловием и счетчиком. Может использовать комбинированные условия продолжения/выхода и несколько управляющих переменных.
6. Вложенные циклы - Архитектурная конструкция, при которой один цикл располагается внутри тела другого цикла. Каждый проход внешнего цикла вызывает полное выполнение внутреннего цикла, что особенно полезно для обработки многомерных данных и матричных операций.
7. Принцип проектирования программ «сверху-вниз» - Методология разработки, при которой программа сначала проектируется на высоком уровне абстракции с последующей детализацией компонентов. Начинается с определения основных модулей и их взаимодействия, затем каждый модуль постепенно разбивается на более мелкие подзадачи до уровня элементарных операций.
8. История появления ООП. Основные этапы -  
 * **1960-е годы:** Зарождение концепций
  - Simula (1967) - первый язык с классами и объектами
  - Алан Кей вводит термин "объектно-ориентированное программирование"
  - Основные принципы: инкапсуляция, наследование, полиморфизм

* **1970-е годы:** Развитие идей
  - Smalltalk (1972) - первый чистый ООП-язык
  - Разработка концепций сообщений и динамической диспетчеризации

* **1980-1990-е годы:** Массовое распространение
  - C++ (1983) - расширение C ООП-возможностями
  - Objective-C, Eiffel, Java
  - Стандартизация UML для объектного моделирования
9. Связь ООП с другими парадигмами программирования - 
* **С процедурным программированием:** ООП развивает идеи модульности и абстракции  
* **С функциональным программированием:**  
- Общие черты: абстракция, композиция  
- Различия: состояние vs бессостоятельность, мутабельность vs иммутабельность  
* **С логическим программированием:** ООП фокусируется на данных и поведении, логическое - на отношениях и правилах  
* **С аспектно-ориентированным программированием:** АОП дополняет ООП, решая проблемы сквозной функциональности
10. Чистые языки, реализующие концепцию ООП. История появления - 
* **Smalltalk (1972):**  
- Первый чистый ООП-язык  
- "Всё - объект", включая классы и примитивы  
- Разработан в Xerox PARC  
  
* **Eiffel (1986):**  
- Бертран Мейер, акцент на проектировании по контракту  
- Множественное наследование, строгая типизация  
  
* **Ruby (1995):**  
- Юкихиро Мацумото, "принцип наименьшего удивления"  
- Динамическая типизация, открытые классы  
  
* **Self (1987):**  
- Прототипно-ориентированный язык, повлиял на JavaScript  
- Отсутствие классов, только объекты
11. Мультипарадигмальные языки, реализующие концепцию ООП. История появления - 
* **C++ (1983):** Бьярн Страуструп, компилируемый язык  
- ООП + процедурное + обобщенное программирование  
- Эффективность C с ООП-возможностями  
  
* **Python (1991):** Гвидо ван Россум  
- ООП + функциональное + императивное программирование  
- Динамическая типизация, читаемый синтаксис  
  
* **Java (1995):** Sun Microsystems  
- ООП + императивное программирование  
- "Write once, run anywhere", виртуальная машина  
  
* **C# (2000):** Microsoft  
- ООП + компонентно-ориентированное + функциональное  
- Развитие идей Java и C++
12. Особенности языка программирования R -
* **Статистическая направленность:** Создан статистиками для статистиков  
* **Функциональная парадигма:** Функции как объекты первого класса  
* **Векторизация:** Операции над векторами без явных циклов  
* **S3/S4 системы ООП:** Нестандартная реализация объектной системы  
* **Интерактивность:** REPL-окружение для исследования данных  
* **Пакетная экосистема:** CRAN с тысячами специализированных пакетов  
* **Графические возможности:** Мощная система визуализации  
* **Интеграция с другими языками:** Интерфейсы к C, C++, Python, Java
13. Языки, поддерживающие парадигму векторизации -
* **R:** Встроенная поддержка векторных операций  
* **MATLAB/Octave:** Матричные операции как основа языка  
* **Julia:** Высокопроизводительные векторные вычисления  
* **Python с NumPy:** Библиотека для научных вычислений  
* **APL/J/K:** Специализированные языки для обработки массивов  
* **Fortran 90+:** Современные версии с array operations  
* **SAS/IML:** Матричные операции в статистическом пакете
14. CRAN -
* **Определение:** Сеть архивов с пакетами для R  
* **Основан:** 1997 год  
* **Содержание:**  
- Более 19,000 пакетов (на 2023 год)  
- Документация, исходный код  
- Руководства и виньетки  
* **Функции:**  
- Централизованный репозиторий  
- Система проверки пакетов  
- Автоматическое построение для разных платформ  
* **Процесс публикации:** Строгий ревью кода и документации
15. Плюсы и минусы языка R -
**Плюсы:**
* ✓ Богатая статистическая функциональность
* ✓ Мощная визуализация (ggplot2, lattice)
* ✓ Активное сообщество и обширная экосистема пакетов
* ✓ Бесплатность и открытый исходный код
* ✓ Отличная документация и обучающие ресурсы
* ✓ Поддержка воспроизводимых исследований (R Markdown)
* ✓ Интеграция с другими языками и инструментами

**Минусы:**
* ✗ Низкая производительность в вычислительно сложных задачах
* ✗ Своеобразный синтаксис, сложный для новичков
* ✗ Проблемы с управлением памятью для больших данных
* ✗ Фрагментированная объектная система
* ✗ Отсутствие стандартов стиля кодирования
* ✗ Ограниченные возможности для веб-разработки
* ✗ Сложности в разработке больших приложений

R остается доминирующим языком в академической статистике и data science, хотя в промышленности часто уступает Python из-за лучшей производительности и универсальности последнего.

## Приложения
- [Исходный код](https://github.com/Nocotov77/GerdaNA/blob/main/lab-02/project )
- ![Диаграмма](https://raw.githubusercontent.com/Nocotov77/GerdaNA/main/lab-02/report/z1.png)
- ![Диаграмма 1](https://raw.githubusercontent.com/Nocotov77/GerdaNA/refs/heads/main/lab-02/report/z2.png)
- ![Диаграмма 2](https://raw.githubusercontent.com/Nocotov77/GerdaNA/refs/heads/main/lab-02/report/z3.png)