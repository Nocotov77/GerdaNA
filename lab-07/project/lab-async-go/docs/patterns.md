# 9 паттернов параллелизма в Go

## 1. Worker Pool паттерн

### Описание
Worker Pool - это паттерн, при котором фиксированное количество рабочих горутин обрабатывает задачи из общей очереди.

### Когда использовать
- Обработка большого количества независимых задач
- Ограничение использования системных ресурсов
- Справедливое распределение работы между рабочими

### Преимущества
- Контролируемое использование памяти
- Предсказуемая производительность
- Легко добавлять/удалять рабочих

### Реализация
\`\`\`go
type WorkerPool struct {
    workers  int
    tasksCh  chan func()
    stopChan chan struct{}
    wg       sync.WaitGroup
}
\`\`\`

### Время ответа
- Небольшое количество задач: O(n/workers)
- Большое количество задач: зависит от сложности задачи

---

## 2. Producer-Consumer паттерн

### Описание
Один или несколько производителей создают данные и отправляют в канал, потребители получают и обрабатывают.

### Когда использовать
- Асинхронная обработка событий
- Распределение нагрузки между компонентами
- Системы с различными скоростями обработки

### Преимущества
- Слабая связанность между компонентами
- Выравнивание скоростей обработки
- Простота расширения

### Диаграмма
\`\`\`
Producer1 ──┐
Producer2 ──┤──→ Channel ──→ Consumer1
Producer3 ──┘              ├─→ Consumer2
\`\`\`

---

## 3. Pipeline паттерн

### Описание
Данные проходят через несколько последовательных этапов обработки, каждый в отдельной горутине.

### Когда использовать
- Многоэтапная обработка данных
- Трансформация данных между этапами
- Каскадная обработка информации

### Преимущества
- Естественное представление потока обработки
- Независимая масштабируемость этапов
- Легко добавлять новые этапы

### Формула производительности
```
Throughput = 1 / max(stage1_latency, stage2_latency, ...)
```

---

## 4. Fan-Out/Fan-In паттерн

### Описание
Fan-Out: разделяем одну задачу на несколько подзадач, обрабатываются параллельно
Fan-In: собираем результаты из нескольких каналов в один

### Когда использовать
- Распараллеливание независимых подзадач
- Использование всех ядер процессора
- Снижение общего времени выполнения

### Ускорение (Speedup)
Согласно закону Амдала: S = 1 / (1 - P + P/N)
где P - доля параллелизуемого кода, N - количество ядер

---

## 5. Rate Limiter паттерн

### Описание
Ограничивает частоту выполнения операций до определенного числа в секунду.

### Когда использовать
- API rate limiting
- Защита от перегрузки
- Регулирование потребления ресурсов

### Реализация
\`\`\`go
type RateLimiter struct {
    ticker   *time.Ticker
    ch       chan struct{}
    stopChan chan struct{}
}
\`\`\`

### Характеристики
- O(1) операция лимитирования
- Token bucket алгоритм
- Поддержка bursting

---

## 6. Semaphore паттерн

### Описание
Контролирует доступ к ресурсам, ограничивая количество одновременно работающих горутин.

### Когда использовать
- Ограничение одновременных соединений к БД
- Управление пулом ресурсов
- Защита критических участков

### Операции
- Acquire() - получить доступ
- Release() - освободить доступ

### Типы
- Счетный семафор (N ≥ 0)
- Бинарный семафор (N ∈ {0, 1})

---

## 7. Bounded Queue паттерн

### Описание
Очередь с максимальным размером, блокирует добавление при переполнении.

### Когда использовать
- Контроль использования памяти
- Буферизация между быстрым производителем и медленным потребителем
- Защита от всплесков нагрузки

### Характеристики
\`\`\`
┌─────────────────────┐
│ MAX_SIZE = 10       │
├─────────────────────┤
│ Element 1           │
│ Element 2           │
│ Element 3           │
│ ...                 │
├─────────────────────┤
│ Enqueue() → блокировка
│ если queue.size == MAX_SIZE
└─────────────────────┘
\`\`\`

---

## 8. Dynamic Worker Pool паттерн

### Описание
Количество рабочих горутин динамически адаптируется к нагрузке в диапазоне [min, max].

### Когда использовать
- Переменная нагрузка
- Оптимизация использования ресурсов
- Автоматическое масштабирование

### Стратегия масштабирования
- Если работ > max: используем maxWorkers
- Если работ < min: используем minWorkers
- Иначе: создаем новых рабочих по мере необходимости

---

## 9. Priority Queue паттерн

### Описание
Обработка задач с учетом их приоритета. Задачи с выше приоритетом выполняются первыми.

### Когда использовать
- Срочные задачи
- Система с разными классами обслуживания (QoS)
- Справедливое распределение ресурсов

### Примеры приоритетов
```
Priority 1: Критические задачи (срочные запросы)
Priority 5: Обычные задачи
Priority 10: Фоновые задачи (логирование, аналитика)
```

---

## Сравнение паттернов

| Паттерн | Throughput | Latency | Сложность | Когда использовать |
|---------|-----------|---------|-----------|-------------------|
| Worker Pool | Высокий | Средняя | Низкая | Много независимых задач |
| Producer-Consumer | Средний | Низкая | Низкая | Асинхронные события |
| Pipeline | Высокий | Средняя | Средняя | Многоэтапная обработка |
| Fan-Out/Fan-In | Очень высокий | Низкая | Высокая | Параллельные подзадачи |
| Rate Limiter | Средний | Средняя | Низкая | Контроль нагрузки |
| Semaphore | Высокий | Средняя | Средняя | Управление ресурсами |
| Bounded Queue | Средний | Средняя | Низкая | Буферизация |
| Dynamic Worker Pool | Высокий | Средняя | Высокая | Переменная нагрузка |
| Priority Queue | Средний | Низкая | Высокая | Приоритизация |